using System.Diagnostics;
using SickSharp.Format;

namespace SickSharp.Test;

using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Threading;
using NUnit.Framework;


// autogenerated, more or less reasonable
[TestFixture]
public class PageCachedFileTests
{
    private string _tempFile;
    private const int BasePageSize = 4096;
    private static readonly byte[] TestData = new byte[BasePageSize * 4 + 42];

    [OneTimeSetUp]
    public void Setup()
    {
        // Create test file with determenistic content
        _tempFile = Path.GetTempFileName();
        for (int i = 0; i < TestData.Length; i++)
        {
            TestData[i] = (byte)(i % 256);
        }

        File.WriteAllBytes(_tempFile, TestData);
    }

    [OneTimeTearDown]
    public void Cleanup()
    {
        File.Delete(_tempFile);
    }

    #region Basic Functionality Tests

    [Test]
    public void GetPage_ValidPage_ReturnsCorrectData()
    {
        using var cache = new PageCachedFile(_tempFile, BasePageSize);
        var page = cache.GetPage(0);
        Assert.That(page, Is.EqualTo(TestData.Take(BasePageSize).ToArray()));
    }

    [Test]
    public void GetPage_OutOfRange_ThrowsArgumentException()
    {
        using var cache = new PageCachedFile(_tempFile, BasePageSize);
        Assert.Throws<ArgumentOutOfRangeException>(() => cache.GetPage(-1));
        Assert.Throws<ArgumentOutOfRangeException>(() => cache.GetPage(100));
    }

    #endregion

    #region Concurrency Tests

    [Test]
    public void ConcurrentGetPage_SamePage_LoadsOnce()
    {
        using var cache = new PageCachedFile(_tempFile, BasePageSize);
        byte[][] results = new byte[2][];
        
#pragma warning disable CS8601 // Possible null reference assignment.
        Parallel.Invoke(
            () => results[0] = cache.GetPage(0),
            () => results[1] = cache.GetPage(0)
        );
#pragma warning restore CS8601 // Possible null reference assignment.

        Assert.That(results[1], Is.SameAs(results[0]));
        Assert.That(cache.GetPageStatus(0), Is.EqualTo(CachePageStatus.Loaded));
    }

    [Test]
    public void ConcurrentGetPage_DifferentPages_LoadsIndependently()
    {
        using var cache = new PageCachedFile(_tempFile, BasePageSize);
        var barrier = new Barrier(2);

        void LoadPage(int page)
        {
            barrier.SignalAndWait();
            cache.GetPage(page);
        }

        Parallel.Invoke(
            () => LoadPage(0),
            () => LoadPage(1)
        );

        Assert.That(cache.GetPageStatus(0), Is.EqualTo(CachePageStatus.Loaded));
        Assert.That(cache.GetPageStatus(1), Is.EqualTo(CachePageStatus.Loaded));
    }

    #endregion

    #region Disposal Tests
    [Test]
    public void AfterDispose_ThrowsOnAccess()
    {
        var cache = new PageCachedFile(_tempFile, BasePageSize);
        cache.Dispose();
        Assert.Throws<ObjectDisposedException>(() => cache.GetPage(0));
    }

    #endregion

    #region Edge Cases

    [Test]
    public void LastPage_TruncatedCorrectly()
    {
        const int customPageSize = 1500;
        using var cache = new PageCachedFile(_tempFile, customPageSize);
        var lastPage = cache.GetPage(cache.TotalPages - 1);

        Assert.NotNull(lastPage);
        int expectedSize = (int)(new FileInfo(_tempFile).Length % customPageSize);
        Assert.That(lastPage.Length, Is.EqualTo(expectedSize));
    }

    [Test]
    public void ZeroLengthFile_HandlesCorrectly()
    {
        var emptyFile = Path.GetTempFileName();
        using var cache = new PageCachedFile(emptyFile, BasePageSize);

        Assert.That(cache.TotalPages, Is.EqualTo(0));
        Assert.Throws<ArgumentOutOfRangeException>(() => cache.GetPage(0));
        File.Delete(emptyFile);
    }

    #endregion

    #region Stress Tests

    [Test]
    public void HighConcurrency_StressTest()
    {
        using var cache = new PageCachedFile(_tempFile, BasePageSize);
        const int threads = 10;
        const int iterations = 100;

        Parallel.For(0, threads, _ =>
        {
            var random = new Random();
            for (int i = 0; i < iterations; i++)
            {
                var page = random.Next(0, cache.TotalPages);
                var data = cache.GetPage(page);
                Assert.NotNull(data);
                Assert.IsTrue(data.Length == BasePageSize  || data.Length == 42);
            }
        });

        Assert.That(cache.CacheSaturation(), Is.EqualTo(1.0));
    }

    #endregion
}